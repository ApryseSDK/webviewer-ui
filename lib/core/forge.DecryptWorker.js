self["webpackChunk"](["forge"],{

/***/ "./src/core/src/util/forge/forgeaes.js":
/*!*********************************************!*\
  !*** ./src/core/src/util/forge/forgeaes.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _forgeutil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./forgeutil */ \"./src/core/src/util/forge/forgeutil.js\");\n/** @license Advanced Encryption Standard (AES) Cipher-Block Chaining implementation.|This implementation is based on the public domain library 'jscrypto' which|was written by:|Emily Stark (estark@stanford.edu)|Mike Hamburg (mhamburg@stanford.edu)|Dan Boneh (dabo@cs.stanford.edu)|Parts of this code are based on the OpenSSL implementation of AES:|http://www.openssl.org|@author Dave Longley|Copyright (c) 2010-2012 Digital Bazaar, Inc. */\n // define forge\n\nif (typeof window !== 'undefined') {\n  var forge = window.forge = window.forge || {};\n  forge.aes = {};\n} // // define node.js module\n// else if (typeof (module) !== 'undefined' && module.exports) {\n//   var forge = {\n//     util: util\n//   };\n//   module.exports = forge.aes = {};\n// } else if (typeof (self) !== 'undefined') {\n//   var forge = self.forge = self.forge || {};\n//   forge.aes = {};\n// }\n\n\nvar forge = {};\nforge.aes = {};\nforge.util = _forgeutil__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nvar init = false; // not yet initialized\n\nvar Nb = 4; // number of words comprising the state (AES = 4)\n\nvar sbox; // non-linear substitution table used in key expansion\n\nvar isbox; // inversion of sbox\n\nvar rcon; // round constant word array\n\nvar mix; // mix-columns table\n\nvar imix; // inverse mix-columns table\n\n/**\r\n * Performs initialization, ie: precomputes tables to optimize for speed.\r\n *\r\n * One way to understand how AES works is to imagine that 'addition' and\r\n * 'multiplication' are interfaces that require certain mathematical\r\n * properties to hold true (ie: they are associative) but they might have\r\n * different implementations and produce different kinds of results ...\r\n * provided that their mathematical properties remain true. AES defines\r\n * its own methods of addition and multiplication but keeps some important\r\n * properties the same, ie: associativity and distributivity. The\r\n * explanation below tries to shed some light on how AES defines addition\r\n * and multiplication of bytes and 32-bit words in order to perform its\r\n * encryption and decryption algorithms.\r\n *\r\n * The basics:\r\n *\r\n * The AES algorithm views bytes as binary representations of polynomials\r\n * that have either 1 or 0 as the coefficients. It defines the addition\r\n * or subtraction of two bytes as the XOR operation. It also defines the\r\n * multiplication of two bytes as a finite field referred to as GF(2^8)\r\n * (Note: 'GF' means \"Galois Field\" which is a field that contains a finite\r\n * number of elements so GF(2^8) has 256 elements).\r\n *\r\n * This means that any two bytes can be represented as binary polynomials;\r\n * when they multiplied together and modularly reduced by an irreducible\r\n * polynomial of the 8th degree, the results are the field GF(2^8). The\r\n * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.\r\n * This multiplication is associative with 0x01 as the identity:\r\n *\r\n * (b * 0x01 = GF(b, 0x01) = b).\r\n *\r\n * The operation GF(b, 0x02) can be performed at the byte level by left\r\n * shifting b once and then XOR'ing it (to perform the modular reduction)\r\n * with 0x11b if b is >= 128. Repeated application of the multiplication\r\n * of 0x02 can be used to implement the multiplication of any two bytes.\r\n *\r\n * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can\r\n * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these\r\n * factors can each be multiplied by 0x57 and then added together. To do\r\n * the multiplication, values for 0x57 multiplied by each of these 3 factors\r\n * can be precomputed and stored in a table. To add them, the values from\r\n * the table are XOR'd together.\r\n *\r\n * AES also defines addition and multiplication of words, that is 4-byte\r\n * numbers represented as polynomials of 3 degrees where the coefficients\r\n * are the values of the bytes.\r\n *\r\n * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.\r\n *\r\n * Addition is performed by XOR'ing like powers of x. Multiplication\r\n * is performed in two steps, the first is an algebriac expansion as\r\n * you would do normally (where addition is XOR). But the result is\r\n * a polynomial larger than 3 degrees and thus it cannot fit in a word. So\r\n * next the result is modularly reduced by an AES-specific polynomial of\r\n * degree 4 which will always produce a polynomial of less than 4 degrees\r\n * such that it will fit in a word. In AES, this polynomial is x^4 + 1.\r\n *\r\n * The modular product of two polynomials 'a' and 'b' is thus:\r\n *\r\n * d(x) = d3x^3 + d2x^2 + d1x + d0\r\n * with\r\n * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)\r\n * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)\r\n * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)\r\n * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)\r\n *\r\n * As a matrix:\r\n *\r\n * [d0] = [a0 a3 a2 a1][b0]\r\n * [d1]   [a1 a0 a3 a2][b1]\r\n * [d2]   [a2 a1 a0 a3][b2]\r\n * [d3]   [a3 a2 a1 a0][b3]\r\n *\r\n * Special polynomials defined by AES (0x02 == {02}):\r\n * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}\r\n * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.\r\n *\r\n * These polynomials are used in the MixColumns() and InverseMixColumns()\r\n * operations, respectively, to cause each element in the state to affect\r\n * the output (referred to as diffusing).\r\n *\r\n * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the\r\n * polynomial x3.\r\n *\r\n * The ShiftRows() method modifies the last 3 rows in the state (where\r\n * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.\r\n * The 1st byte in the second row is moved to the end of the row. The 1st\r\n * and 2nd bytes in the third row are moved to the end of the row. The 1st,\r\n * 2nd, and 3rd bytes are moved in the fourth row.\r\n *\r\n * More details on how AES arithmetic works:\r\n *\r\n * In the polynomial representation of binary numbers, XOR performs addition\r\n * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)\r\n * corresponds with the multiplication of polynomials modulo an irreducible\r\n * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply\r\n * polynomial 'a' with polynomial 'b' and then do a modular reduction by\r\n * an AES-specific irreducible polynomial of degree 8.\r\n *\r\n * A polynomial is irreducible if its only divisors are one and itself. For\r\n * the AES algorithm, this irreducible polynomial is:\r\n *\r\n * m(x) = x^8 + x^4 + x^3 + x + 1,\r\n *\r\n * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:\r\n * 100011011 = 283 = 0x11b.\r\n *\r\n * For example, GF(0x57, 0x83) = 0xc1 because\r\n *\r\n * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1\r\n * 0x85 = 131 = 10000101 = x^7 + x + 1\r\n *\r\n * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)\r\n * =  x^13 + x^11 + x^9 + x^8 + x^7 +\r\n *    x^7 + x^5 + x^3 + x^2 + x +\r\n *    x^6 + x^4 + x^2 + x + 1\r\n * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y\r\n *    y modulo (x^8 + x^4 + x^3 + x + 1)\r\n * =  x^7 + x^6 + 1.\r\n *\r\n * The modular reduction by m(x) guarantees the result will be a binary\r\n * polynomial of less than degree 8, so that it can fit in a byte.\r\n *\r\n * The operation to multiply a binary polynomial b with x (the polynomial\r\n * x in binary representation is 00000010) is:\r\n *\r\n * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1\r\n *\r\n * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the\r\n * most significant bit is 0 in b) then the result is already reduced. If\r\n * it is 1, then we can reduce it by subtracting m(x) via an XOR.\r\n *\r\n * It follows that multiplication by x (00000010 or 0x02) can be implemented\r\n * by performing a left shift followed by a conditional bitwise XOR with\r\n * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by\r\n * higher powers of x can be implemented by repeated application of xtime().\r\n *\r\n * By adding intermediate results, multiplication by any constant can be\r\n * implemented. For instance:\r\n *\r\n * GF(0x57, 0x13) = 0xfe because:\r\n *\r\n * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)\r\n *\r\n * Note: We XOR with 0x11b instead of 0x1b because in javascript our\r\n * datatype for b can be larger than 1 byte, so a left shift will not\r\n * automatically eliminate bits that overflow a byte ... by XOR'ing the\r\n * overflow bit with 1 (the extra one from 0x11b) we zero it out.\r\n *\r\n * GF(0x57, 0x02) = xtime(0x57) = 0xae\r\n * GF(0x57, 0x04) = xtime(0xae) = 0x47\r\n * GF(0x57, 0x08) = xtime(0x47) = 0x8e\r\n * GF(0x57, 0x10) = xtime(0x8e) = 0x07\r\n *\r\n * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))\r\n *\r\n * And by the distributive property (since XOR is addition and GF() is\r\n * multiplication):\r\n *\r\n * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)\r\n * = 0x57 ^ 0xae ^ 0x07\r\n * = 0xfe.\r\n */\n\nvar initialize = function initialize() {\n  init = true;\n  /* Populate the Rcon table. These are the values given by\r\n    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)\r\n    in the field of GF(2^8), where i starts at 1.\r\n      rcon[0] = [0x00, 0x00, 0x00, 0x00]\r\n    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1\r\n    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2\r\n    ...\r\n    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B\r\n    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36\r\n      We only store the first byte because it is the only one used.\r\n  */\n\n  rcon = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]; // compute xtime table which maps i onto GF(i, 0x02)\n\n  var xtime = new Array(256);\n\n  for (var i = 0; i < 128; ++i) {\n    xtime[i] = i << 1;\n    xtime[i + 128] = i + 128 << 1 ^ 0x11B;\n  } // compute all other tables\n\n\n  sbox = new Array(256);\n  isbox = new Array(256);\n  mix = new Array(4);\n  imix = new Array(4);\n\n  for (var i = 0; i < 4; ++i) {\n    mix[i] = new Array(256);\n    imix[i] = new Array(256);\n  }\n\n  var e = 0;\n  var ei = 0;\n  var e2;\n  var e4;\n  var e8;\n  var sx;\n  var sx2;\n  var me;\n  var ime;\n\n  for (var i = 0; i < 256; ++i) {\n    /* We need to generate the SubBytes() sbox and isbox tables so that\r\n      we can perform byte substitutions. This requires us to traverse\r\n      all of the elements in GF, find their multiplicative inverses,\r\n      and apply to each the following affine transformation:\r\n        bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^\r\n            b(i + 7) mod 8 ^ ci\r\n      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the\r\n      ith bit of a byte c with the value {63} or {01100011}.\r\n        It is possible to traverse every possible value in a Galois field\r\n      using what is referred to as a 'generator'. There are many\r\n      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully\r\n      traverse GF we iterate 255 times, multiplying by our generator\r\n      each time.\r\n        On each iteration we can determine the multiplicative inverse for\r\n      the current element.\r\n        Suppose there is an element in GF 'e'. For a given generator 'g',\r\n      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns\r\n      out that if use the inverse of a generator as another generator\r\n      it will produce all of the corresponding multiplicative inverses\r\n      at the same time. For this reason, we choose 5 as our inverse\r\n      generator because it only requires 2 multiplies and 1 add and its\r\n      inverse, 82, requires relatively few operations as well.\r\n        In order to apply the affine transformation, the multiplicative\r\n      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a\r\n      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and\r\n      'x'. Then 's' is left shifted and the high bit of 's' is made the\r\n      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd\r\n      with 's' and stored in 'x'. On each subsequent iteration the same\r\n      operation is performed. When 4 iterations are complete, 'x' is\r\n      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.\r\n      For example:\r\n        s = 01000001\r\n      x = 01000001\r\n        iteration 1: s = 10000010, x ^= s\r\n      iteration 2: s = 00000101, x ^= s\r\n      iteration 3: s = 00001010, x ^= s\r\n      iteration 4: s = 00010100, x ^= s\r\n      x ^= 0x63\r\n        This can be done with a loop where s = (s << 1) | (s >> 7). However,\r\n      it can also be done by using a single 16-bit (in this case 32-bit)\r\n      number 'sx'. Since XOR is an associative operation, we can set 'sx'\r\n      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.\r\n      The most significant bits will flow into the high 8 bit positions\r\n      and be correctly XOR'd with one another. All that remains will be\r\n      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits\r\n      afterwards.\r\n        At the same time we're populating sbox and isbox we can precompute\r\n      the multiplication we'll need to do to do MixColumns() later.\r\n    */\n    // apply affine transformation\n    sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;\n    sx = sx >> 8 ^ sx & 255 ^ 0x63; // update tables\n\n    sbox[e] = sx;\n    isbox[sx] = e;\n    /* Mixing columns is done using matrix multiplication. The columns\r\n      that are to be mixed are each a single word in the current state.\r\n      The state has Nb columns (4 columns). Therefore each column is a\r\n      4 byte word. So to mix the columns in a single column 'c' where\r\n      its rows are r0, r1, r2, and r3, we use the following matrix\r\n      multiplication:\r\n        [2 3 1 1]*[r0,c]=[r'0,c]\r\n      [1 2 3 1] [r1,c] [r'1,c]\r\n      [1 1 2 3] [r2,c] [r'2,c]\r\n      [3 1 1 2] [r3,c] [r'3,c]\r\n        r0, r1, r2, and r3 are each 1 byte of one of the words in the\r\n      state (a column). To do matrix multiplication for each mixed\r\n      column c' we multiply the corresponding row from the left matrix\r\n      with the corresponding column from the right matrix. In total, we\r\n      get 4 equations:\r\n        r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c\r\n      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c\r\n      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c\r\n      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c\r\n        As usual, the multiplication is as previously defined and the\r\n      addition is XOR. In order to optimize mixing columns we can store\r\n      the multiplication results in tables. If you think of the whole\r\n      column as a word (it might help to visualize by mentally rotating\r\n      the equations above by counterclockwise 90 degrees) then you can\r\n      see that it would be useful to map the multiplications performed on\r\n      each byte (r0, r1, r2, r3) onto a word as well. For instance, we\r\n      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the\r\n      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two\r\n      respectively in the middle). This means that a table can be\r\n      constructed that uses r0 as an index to the word. We can do the\r\n      same with r1, r2, and r3, creating a total of 4 tables.\r\n        To construct a full c', we can just look up each byte of c in\r\n      their respective tables and XOR the results together.\r\n        Also, to build each table we only have to calculate the word\r\n      for 2,1,1,3 for every byte ... which we can do on each iteration\r\n      of this loop since we will iterate over every byte. After we have\r\n      calculated 2,1,1,3 we can get the results for the other tables\r\n      by cycling the byte at the end to the beginning. For instance\r\n      we can take the result of table 2,1,1,3 and produce table 3,2,1,1\r\n      by moving the right most byte to the left most position just like\r\n      how you can imagine the 3 moved out of 2,1,1,3 and to the front\r\n      to produce 3,2,1,1.\r\n        There is another optimization in that the same multiples of\r\n      the current element we need in order to advance our generator\r\n      to the next iteration can be reused in performing the 2,1,1,3\r\n      calculation. We also calculate the inverse mix column tables,\r\n      with e,9,d,b being the inverse of 2,1,1,3.\r\n        When we're done, and we need to actually mix columns, the first\r\n      byte of each state word should be put through mix[0] (2,1,1,3),\r\n      the second through mix[1] (3,2,1,1) and so forth. Then they should\r\n      be XOR'd together to produce the fully mixed column.\r\n    */\n    // calculate mix and imix table values\n\n    sx2 = xtime[sx];\n    e2 = xtime[e];\n    e4 = xtime[e2];\n    e8 = xtime[e4];\n    me = sx2 << 24 ^ // 2\n    sx << 16 // 1\n    ^ sx << 8 // 1\n    ^ (sx ^ sx2); // 3\n\n    ime = (e2 ^ e4 ^ e8) << 24 // E (14)\n    ^ (e ^ e8) << 16 // 9\n    ^ (e ^ e4 ^ e8) << 8 // D (13)\n    ^ (e ^ e2 ^ e8); // B (11)\n    // produce each of the mix tables by rotating the 2,1,1,3 value\n\n    for (var n = 0; n < 4; ++n) {\n      mix[n][e] = me;\n      imix[n][sx] = ime; // cycle the right most byte to the left most position\n      // ie: 2,1,1,3 becomes 3,2,1,1\n\n      me = me << 24 | me >>> 8;\n      ime = ime << 24 | ime >>> 8;\n    } // get next element and inverse\n\n\n    if (e === 0) {\n      // 1 is the inverse of 1\n      e = ei = 1;\n    } else {\n      // e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)\n      // ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)\n      e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];\n      ei ^= xtime[xtime[ei]];\n    }\n  }\n};\n/**\r\n * Generates a key schedule using the AES key expansion algorithm.\r\n *\r\n * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion\r\n * routine to generate a key schedule. The Key Expansion generates a total\r\n * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,\r\n * and each of the Nr rounds requires Nb words of key data. The resulting\r\n * key schedule consists of a linear array of 4-byte words, denoted [wi ],\r\n * with i in the range 0 ≤ i < Nb(Nr + 1).\r\n *\r\n * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)\r\n * AES-128 (Nb=4, Nk=4, Nr=10)\r\n * AES-192 (Nb=4, Nk=6, Nr=12)\r\n * AES-256 (Nb=4, Nk=8, Nr=14)\r\n * Note: Nr=Nk+6.\r\n *\r\n * Nb is the number of columns (32-bit words) comprising the State (or\r\n * number of bytes in a block). For AES, Nb=4.\r\n *\r\n * @param key the key to schedule (as an array of 32-bit words).\r\n * @param decrypt true to modify the key schedule to decrypt, false not to.\r\n *\r\n * @return the generated key schedule.\r\n */\n\n\nvar expandKey = function expandKey(key, decrypt) {\n  // copy the key's words to initialize the key schedule\n  var w = key.slice(0);\n  /* RotWord() will rotate a word, moving the first byte to the last\r\n    byte's position (shifting the other bytes left).\r\n      We will be getting the value of Rcon at i / Nk. 'i' will iterate\r\n    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in\r\n    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from\r\n    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will\r\n    increase by 1. We use a counter iNk to keep track of this.\r\n    */\n  // go through the rounds expanding the key\n\n  var temp;\n  var iNk = 1;\n  var Nk = w.length;\n  var Nr1 = Nk + 6 + 1;\n  var end = Nb * Nr1;\n\n  for (var i = Nk; i < end; ++i) {\n    temp = w[i - 1];\n\n    if (i % Nk === 0) {\n      // temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]\n      temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;\n      iNk++;\n    } else if (Nk > 6 && i % Nk == 4) {\n      // temp = SubWord(temp)\n      temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];\n    }\n\n    w[i] = w[i - Nk] ^ temp;\n  }\n  /* When we are updating a cipher block we always use the code path for\r\n      encryption whether we are decrypting or not (to shorten code and\r\n      simplify the generation of look up tables). However, because there\r\n      are differences in the decryption algorithm, other than just swapping\r\n      in different look up tables, we must transform our key schedule to\r\n      account for these changes:\r\n        1. The decryption algorithm gets its key rounds in reverse order.\r\n      2. The decryption algorithm adds the round key before mixing columns\r\n        instead of afterwards.\r\n        We don't need to modify our key schedule to handle the first case,\r\n      we can just traverse the key schedule in reverse order when decrypting.\r\n        The second case requires a little work.\r\n        The tables we built for performing rounds will take an input and then\r\n      perform SubBytes() and MixColumns() or, for the decrypt version,\r\n      InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires\r\n      us to AddRoundKey() before InvMixColumns(). This means we'll need to\r\n      apply some transformations to the round key to inverse-mix its columns\r\n      so they'll be correct for moving AddRoundKey() to after the state has\r\n      had its columns inverse-mixed.\r\n        To inverse-mix the columns of the state when we're decrypting we use a\r\n      lookup table that will apply InvSubBytes() and InvMixColumns() at the\r\n      same time. However, the round key's bytes are not inverse-substituted\r\n      in the decryption algorithm. To get around this problem, we can first\r\n      substitute the bytes in the round key so that when we apply the\r\n      transformation via the InvSubBytes()+InvMixColumns() table, it will\r\n      undo our substitution leaving us with the original value that we\r\n      want -- and then inverse-mix that value.\r\n        This change will correctly alter our key schedule so that we can XOR\r\n      each round key with our already transformed decryption state. This\r\n      allows us to use the same code path as the encryption algorithm.\r\n        We make one more change to the decryption key. Since the decryption\r\n      algorithm runs in reverse from the encryption algorithm, we reverse\r\n      the order of the round keys to avoid having to iterate over the key\r\n      schedule backwards when running the encryption algorithm later in\r\n      decryption mode. In addition to reversing the order of the round keys,\r\n      we also swap each round key's 2nd and 4th rows. See the comments\r\n      section where rounds are performed for more details about why this is\r\n      done. These changes are done inline with the other substitution\r\n      described above.\r\n  */\n\n\n  if (decrypt) {\n    var tmp;\n    var m0 = imix[0];\n    var m1 = imix[1];\n    var m2 = imix[2];\n    var m3 = imix[3];\n    var wnew = w.slice(0);\n    var end = w.length;\n\n    for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {\n      // do not sub the first or last round key (round keys are Nb\n      // words) as no column mixing is performed before they are added,\n      // but do change the key order\n      if (i === 0 || i === end - Nb) {\n        wnew[i] = w[wi];\n        wnew[i + 1] = w[wi + 3];\n        wnew[i + 2] = w[wi + 2];\n        wnew[i + 3] = w[wi + 1];\n      } else {\n        // substitute each round key byte because the inverse-mix\n        // table will inverse-substitute it (effectively cancel the\n        // substitution because round key bytes aren't sub'd in\n        // decryption mode) and swap indexes 3 and 1\n        for (var n = 0; n < Nb; ++n) {\n          tmp = w[wi + n];\n          wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];\n        }\n      }\n    }\n\n    w = wnew;\n  }\n\n  return w;\n};\n/**\r\n * Updates a single block (16 bytes) using AES. The update will either\r\n * encrypt or decrypt the block.\r\n *\r\n * @param w the key schedule.\r\n * @param input the input block (an array of 32-bit words).\r\n * @param output the updated output block.\r\n * @param decrypt true to decrypt the block, false to encrypt it.\r\n */\n\n\nvar _updateBlock = function _updateBlock(w, input, output, decrypt) {\n  /*\r\n  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])\r\n  begin\r\n    byte state[4,Nb]\r\n    state = in\r\n    AddRoundKey(state, w[0, Nb-1])\r\n    for round = 1 step 1 to Nr–1\r\n      SubBytes(state)\r\n      ShiftRows(state)\r\n      MixColumns(state)\r\n      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\r\n    end for\r\n    SubBytes(state)\r\n    ShiftRows(state)\r\n    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r\n    out = state\r\n  end\r\n    InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])\r\n  begin\r\n    byte state[4,Nb]\r\n    state = in\r\n    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r\n    for round = Nr-1 step -1 downto 1\r\n      InvShiftRows(state)\r\n      InvSubBytes(state)\r\n      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\r\n      InvMixColumns(state)\r\n    end for\r\n    InvShiftRows(state)\r\n    InvSubBytes(state)\r\n    AddRoundKey(state, w[0, Nb-1])\r\n    out = state\r\n  end\r\n  */\n  // Encrypt: AddRoundKey(state, w[0, Nb-1])\n  // Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\n  var Nr = w.length / 4 - 1;\n  var m0;\n  var m1;\n  var m2;\n  var m3;\n  var sub;\n\n  if (decrypt) {\n    m0 = imix[0];\n    m1 = imix[1];\n    m2 = imix[2];\n    m3 = imix[3];\n    sub = isbox;\n  } else {\n    m0 = mix[0];\n    m1 = mix[1];\n    m2 = mix[2];\n    m3 = mix[3];\n    sub = sbox;\n  }\n\n  var a;\n  var b;\n  var c;\n  var d;\n  var a2;\n  var b2;\n  var c2;\n  a = input[0] ^ w[0];\n  b = input[decrypt ? 3 : 1] ^ w[1];\n  c = input[2] ^ w[2];\n  d = input[decrypt ? 1 : 3] ^ w[3];\n  var i = 3;\n  /* In order to share code we follow the encryption algorithm when both\r\n    encrypting and decrypting. To account for the changes required in the\r\n    decryption algorithm, we use different lookup tables when decrypting\r\n    and use a modified key schedule to account for the difference in the\r\n    order of transformations applied when performing rounds. We also get\r\n    key rounds in reverse order (relative to encryption). */\n\n  for (var round = 1; round < Nr; ++round) {\n    /* As described above, we'll be using table lookups to perform the\r\n      column mixing. Each column is stored as a word in the state (the\r\n      array 'input' has one column as a word at each index). In order to\r\n      mix a column, we perform these transformations on each row in c,\r\n      which is 1 byte in each word. The new column for c0 is c'0:\r\n                  m0      m1      m2      m3\r\n      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0\r\n      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0\r\n      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0\r\n      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0\r\n        So using mix tables where c0 is a word with r0 being its upper\r\n      8 bits and r3 being its lower 8 bits:\r\n        m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]\r\n      ...\r\n      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]\r\n        Therefore to mix the columns in each word in the state we\r\n      do the following (& 255 omitted for brevity):\r\n      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r\n      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r\n      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r\n      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]\r\n        However, before mixing, the algorithm requires us to perform\r\n      ShiftRows(). The ShiftRows() transformation cyclically shifts the\r\n      last 3 rows of the state over different offsets. The first row\r\n      (r = 0) is not shifted.\r\n        s'_r,c = s_r,(c + shift(r, Nb) mod Nb\r\n      for 0 < r < 4 and 0 <= c < Nb and\r\n      shift(1, 4) = 1\r\n      shift(2, 4) = 2\r\n      shift(3, 4) = 3.\r\n        This causes the first byte in r = 1 to be moved to the end of\r\n      the row, the first 2 bytes in r = 2 to be moved to the end of\r\n      the row, the first 3 bytes in r = 3 to be moved to the end of\r\n      the row:\r\n        r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]\r\n      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]\r\n      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]\r\n        We can make these substitutions inline with our column mixing to\r\n      generate an updated set of equations to produce each word in the\r\n      state (note the columns have changed positions):\r\n        c0 c1 c2 c3 => c0 c1 c2 c3\r\n      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)\r\n      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)\r\n      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)\r\n        Therefore:\r\n        c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3\r\n      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3\r\n      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3\r\n      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3\r\n        c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0\r\n      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0\r\n      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0\r\n      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0\r\n        ... and so forth for c'2 and c'3. The important distinction is\r\n      that the columns are cycling, with c0 being used with the m0\r\n      map when calculating c0, but c1 being used with the m0 map when\r\n      calculating c1 ... and so forth.\r\n        When performing the inverse we transform the mirror image and\r\n      skip the bottom row, instead of the top one, and move upwards:\r\n        c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption\r\n      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)\r\n      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption\r\n      c3 c2 c1 c0    c3 c2 c1 c0\r\n        If you compare the resulting matrices for ShiftRows()+MixColumns()\r\n      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are\r\n      different (in encrypt mode vs. decrypt mode). So in order to use\r\n      the same code to handle both encryption and decryption, we will\r\n      need to do some mapping.\r\n        If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be\r\n      a row number in the state, then the resulting matrix in encryption\r\n      mode for applying the above transformations would be:\r\n        r1: a b c d\r\n      r2: b c d a\r\n      r3: c d a b\r\n      r4: d a b c\r\n        If we did the same in decryption mode we would get:\r\n        r1: a d c b\r\n      r2: b a d c\r\n      r3: c b a d\r\n      r4: d c b a\r\n        If instead we swap d and b (set b=c3 and d=c1), then we get:\r\n        r1: a b c d\r\n      r2: d a b c\r\n      r3: c d a b\r\n      r4: b c d a\r\n        Now the 1st and 3rd rows are the same as the encryption matrix. All\r\n      we need to do then to make the mapping exactly the same is to swap\r\n      the 2nd and 4th rows when in decryption mode. To do this without\r\n      having to do it on each iteration, we swapped the 2nd and 4th rows\r\n      in the decryption key schedule. We also have to do the swap above\r\n      when we first pull in the input and when we set the final output. */\n    a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];\n    b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];\n    c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];\n    d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];\n    a = a2;\n    b = b2;\n    c = c2;\n  }\n  /*\r\n    Encrypt:\r\n    SubBytes(state)\r\n    ShiftRows(state)\r\n    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r\n      Decrypt:\r\n    InvShiftRows(state)\r\n    InvSubBytes(state)\r\n    AddRoundKey(state, w[0, Nb-1])\r\n    */\n  // Note: rows are shifted inline\n\n\n  output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];\n  output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];\n  output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];\n  output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];\n};\n/**\r\n * Creates an AES cipher object. CBC (cipher-block-chaining) mode will be\r\n * used.\r\n *\r\n * The key and iv may be given as a string of bytes, an array of bytes, a\r\n * byte buffer, or an array of 32-bit words. If an iv is provided, then\r\n * encryption/decryption will be started, otherwise start() must be called\r\n * with an iv.\r\n *\r\n * @param key the symmetric key to use.\r\n * @param iv the initialization vector to start with, null not to start.\r\n * @param output the buffer to write to.\r\n * @param decrypt true for decryption, false for encryption.\r\n *\r\n * @return the cipher.\r\n */\n\n\nvar _createCipher = function _createCipher(key, iv, output, decrypt) {\n  var cipher = null;\n\n  if (!init) {\n    initialize();\n  }\n  /* Note: The key may be a string of bytes, an array of bytes, a byte\r\n    buffer, or an array of 32-bit integers. If the key is in bytes, then\r\n    it must be 16, 24, or 32 bytes in length. If it is in 32-bit\r\n    integers, it must be 4, 6, or 8 integers long. */\n  // convert key string into byte buffer\n\n\n  if (key.constructor == String && (key.length == 16 || key.length == 24 || key.length == 32)) {\n    key = forge.util.createBuffer(key);\n  } // convert key integer array into byte buffer\n  else if (key.constructor == Array && (key.length == 16 || key.length == 24 || key.length == 32)) {\n      var tmp = key;\n      var key = forge.util.createBuffer();\n\n      for (var i = 0; i < tmp.length; ++i) {\n        key.putByte(tmp[i]);\n      }\n    } // convert key byte buffer into 32-bit integer array\n\n\n  if (key.constructor != Array) {\n    var tmp = key;\n    key = []; // key lengths of 16, 24, 32 bytes allowed\n\n    var len = tmp.length();\n\n    if (len == 16 || len == 24 || len == 32) {\n      len >>>= 2;\n\n      for (var i = 0; i < len; ++i) {\n        key.push(tmp.getInt32());\n      }\n    }\n  } // key must be an array of 32-bit integers by now\n\n\n  if (key.constructor == Array && (key.length == 4 || key.length == 6 || key.length == 8)) {\n    // private vars for state\n    var _w = expandKey(key, decrypt);\n\n    var _blockSize = Nb << 2;\n\n    var _input;\n\n    var _output;\n\n    var _inBlock;\n\n    var _outBlock;\n\n    var _prev;\n\n    var _finish;\n\n    cipher = {\n      // output from AES (either encrypted or decrypted bytes)\n      output: null\n    };\n    /**\r\n     * Updates the next block using CBC mode.\r\n     *\r\n     * @param input the buffer to read from.\r\n     */\n\n    cipher.update = function (input) {\n      if (!_finish) {\n        // not finishing, so fill the input buffer with more input\n        _input.putBuffer(input);\n      }\n      /* In encrypt mode, the threshold for updating a block is the\r\n        block size. As soon as enough input is available to update\r\n        a block, encryption may occur. In decrypt mode, we wait for\r\n        2 blocks to be available or for the finish flag to be set\r\n        with only 1 block available. This is done so that the output\r\n        buffer will not be populated with padding bytes at the end\r\n        of the decryption -- they can be truncated before returning\r\n        from finish(). */\n\n\n      var threshold = decrypt && !_finish ? _blockSize << 1 : _blockSize;\n\n      while (_input.length() >= threshold) {\n        // get next block\n        if (decrypt) {\n          for (var i = 0; i < Nb; ++i) {\n            _inBlock[i] = _input.getInt32();\n          }\n        } else {\n          // CBC mode XOR's IV (or previous block) with plaintext\n          for (var i = 0; i < Nb; ++i) {\n            _inBlock[i] = _prev[i] ^ _input.getInt32();\n          }\n        } // update block\n\n\n        _updateBlock(_w, _inBlock, _outBlock, decrypt); // write output, save previous ciphered block\n\n\n        if (decrypt) {\n          // CBC mode XOR's IV (or previous block) with plaintext\n          for (var i = 0; i < Nb; ++i) {\n            _output.putInt32(_prev[i] ^ _outBlock[i]);\n          }\n\n          _prev = _inBlock.slice(0);\n        } else {\n          for (var i = 0; i < Nb; ++i) {\n            _output.putInt32(_outBlock[i]);\n          }\n\n          _prev = _outBlock;\n        }\n      }\n    };\n    /**\r\n     * Finishes encrypting or decrypting.\r\n     *\r\n     * @param pad a padding function to use, null for default,\r\n     *          signature(blockSize, buffer, decrypt).\r\n     *\r\n     * @return true if successful, false on error.\r\n     */\n\n\n    cipher.finish = function (pad) {\n      var rval = true;\n\n      if (!decrypt) {\n        if (pad) {\n          rval = pad(_blockSize, _input, decrypt);\n        } else {\n          // add PKCS#7 padding to block (each pad byte is the\n          // value of the number of pad bytes)\n          var padding = _input.length() == _blockSize ? _blockSize : _blockSize - _input.length();\n\n          _input.fillWithByte(padding, padding);\n        }\n      }\n\n      if (rval) {\n        // do final update\n        _finish = true;\n        cipher.update();\n      }\n\n      if (decrypt) {\n        // check for error: input data not a multiple of blockSize\n        rval = _input.length() === 0;\n\n        if (rval) {\n          if (pad) {\n            rval = pad(_blockSize, _output, decrypt);\n          } else {\n            // ensure padding byte count is valid\n            var len = _output.length();\n\n            var count = _output.at(len - 1);\n\n            if (count > Nb << 2) {\n              rval = false;\n            } else {\n              // trim off padding bytes\n              _output.truncate(count);\n            }\n          }\n        }\n      }\n\n      return rval;\n    };\n    /**\r\n     * Starts or restarts the encryption or decryption process, whichever\r\n     * was previously configured.\r\n     *\r\n     * The iv may be given as a string of bytes, an array of bytes, a\r\n     * byte buffer, or an array of 32-bit words.\r\n     *\r\n     * @param iv the initialization vector to use, null to reuse the\r\n     *          last ciphered block from a previous update().\r\n     * @param output the output the buffer to write to, null to create one.\r\n     */\n\n\n    cipher.start = function (iv, output) {\n      // if IV is null, reuse block from previous encryption/decryption\n      iv = iv || _prev.slice(0);\n      /* Note: The IV may be a string of bytes, an array of bytes, a\r\n        byte buffer, or an array of 32-bit integers. If the IV is in\r\n        bytes, then it must be Nb (16) bytes in length. If it is in\r\n        32-bit integers, then it must be 4 integers long. */\n      // convert iv string into byte buffer\n\n      if (iv.constructor == String && iv.length == 16) {\n        iv = forge.util.createBuffer(iv);\n      } // convert iv byte array into byte buffer\n      else if (iv.constructor == Array && iv.length == 16) {\n          var tmp = iv;\n          var iv = forge.util.createBuffer();\n\n          for (var i = 0; i < 16; ++i) {\n            iv.putByte(tmp[i]);\n          }\n        } // convert iv byte buffer into 32-bit integer array\n\n\n      if (iv.constructor != Array) {\n        var tmp = iv;\n        iv = new Array(4);\n        iv[0] = tmp.getInt32();\n        iv[1] = tmp.getInt32();\n        iv[2] = tmp.getInt32();\n        iv[3] = tmp.getInt32();\n      } // set private vars\n\n\n      _input = forge.util.createBuffer();\n      _output = output || forge.util.createBuffer();\n      _prev = iv.slice(0);\n      _inBlock = new Array(Nb);\n      _outBlock = new Array(Nb);\n      _finish = false;\n      cipher.output = _output;\n    };\n\n    if (iv !== null) {\n      cipher.start(iv, output);\n    }\n  }\n\n  return cipher;\n};\n/* AES API */\n\n/**\r\n * Creates an AES cipher object to encrypt data in CBC mode using the\r\n * given symmetric key. The output will be stored in the 'output' member\r\n * of the returned cipher.\r\n *\r\n * The key and iv may be given as a string of bytes, an array of bytes,\r\n * a byte buffer, or an array of 32-bit words.\r\n *\r\n * @param key the symmetric key to use.\r\n * @param iv the initialization vector to use.\r\n * @param output the buffer to write to, null to create one.\r\n *\r\n * @return the cipher.\r\n */\n\n\nforge.aes.startEncrypting = function (key, iv, output) {\n  return _createCipher(key, iv, output, false);\n};\n/**\r\n * Creates an AES cipher object to encrypt data in CBC mode using the\r\n * given symmetric key.\r\n *\r\n * The key may be given as a string of bytes, an array of bytes, a\r\n * byte buffer, or an array of 32-bit words.\r\n *\r\n * To start encrypting call start() on the cipher with an iv and optional\r\n * output buffer.\r\n *\r\n * @param key the symmetric key to use.\r\n *\r\n * @return the cipher.\r\n */\n\n\nforge.aes.createEncryptionCipher = function (key) {\n  return _createCipher(key, null, null, false);\n};\n/**\r\n * Creates an AES cipher object to decrypt data in CBC mode using the\r\n * given symmetric key. The output will be stored in the 'output' member\r\n * of the returned cipher.\r\n *\r\n * The key and iv may be given as a string of bytes, an array of bytes,\r\n * a byte buffer, or an array of 32-bit words.\r\n *\r\n * @param key the symmetric key to use.\r\n * @param iv the initialization vector to use.\r\n * @param output the buffer to write to, null to create one.\r\n *\r\n * @return the cipher.\r\n */\n\n\nforge.aes.startDecrypting = function (key, iv, output) {\n  return _createCipher(key, iv, output, true);\n};\n/**\r\n * Creates an AES cipher object to decrypt data in CBC mode using the\r\n * given symmetric key.\r\n *\r\n * The key may be given as a string of bytes, an array of bytes, a\r\n * byte buffer, or an array of 32-bit words.\r\n *\r\n * To start decrypting call start() on the cipher with an iv and\r\n * optional output buffer.\r\n *\r\n * @param key the symmetric key to use.\r\n *\r\n * @return the cipher.\r\n */\n\n\nforge.aes.createDecryptionCipher = function (key) {\n  return _createCipher(key, null, null, true);\n};\n/**\r\n * Expands a key. Typically only used for testing.\r\n *\r\n * @param key the symmetric key to expand, as an array of 32-bit words.\r\n * @param decrypt true to expand for decryption, false for encryption.\r\n *\r\n * @return the expanded key.\r\n */\n\n\nforge.aes._expandKey = function (key, decrypt) {\n  if (!init) {\n    initialize();\n  }\n\n  return expandKey(key, decrypt);\n};\n/**\r\n * Updates a single block. Typically only used for testing.\r\n *\r\n * @param w the expanded key to use.\r\n * @param input an array of block-size 32-bit words.\r\n * @param output an array of block-size 32-bit words.\r\n * @param decrypt true to decrypt, false to encrypt.\r\n */\n\n\nforge.aes._updateBlock = _updateBlock;\n/* harmony default export */ __webpack_exports__[\"default\"] = (forge);\n\n//# sourceURL=webpack:///./src/core/src/util/forge/forgeaes.js?");

/***/ }),

/***/ "./src/core/src/util/forge/forgeutil.js":
/*!**********************************************!*\
  !*** ./src/core/src/util/forge/forgeutil.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\r\n * Utility functions for web applications.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2010-2012 Digital Bazaar, Inc.\r\n */\n// // define forge\n// if (typeof (window) !== 'undefined') {\n//   var forge = window.forge = window.forge || {};\n//   forge.util = {};\n// }\n// // define node.js module\n// else if (typeof (module) !== 'undefined' && module.exports) {\n//   var forge = {};\n//   module.exports = forge.util = {};\n// } else if (typeof (self) !== 'undefined') {\n//   var forge = self.forge = self.forge || {};\n//   forge.util = {};\n// }\n\n/* Utilities API */\nvar util = {};\n/**\r\n * Constructor for a byte buffer.\r\n *\r\n * @param b the bytes to wrap (as a UTF-8 string) (optional).\r\n */\n\nutil.ByteBuffer = function (b) {\n  // the data in this buffer\n  this.data = b || ''; // the pointer for reading from this buffer\n\n  this.read = 0;\n};\n/**\r\n * Gets the number of bytes in this buffer.\r\n *\r\n * @return the number of bytes in this buffer.\r\n */\n\n\nutil.ByteBuffer.prototype.length = function () {\n  return this.data.length - this.read;\n};\n/**\r\n * Gets whether or not this buffer is empty.\r\n *\r\n * @return true if this buffer is empty, false if not.\r\n */\n\n\nutil.ByteBuffer.prototype.isEmpty = function () {\n  return this.data.length - this.read === 0;\n};\n/**\r\n * Puts a byte in this buffer.\r\n *\r\n * @param b the byte to put.\r\n */\n\n\nutil.ByteBuffer.prototype.putByte = function (b) {\n  this.data += String.fromCharCode(b);\n};\n/**\r\n * Puts a byte in this buffer N times.\r\n *\r\n * @param b the byte to put.\r\n * @param n the number of bytes of value b to put.\r\n */\n\n\nutil.ByteBuffer.prototype.fillWithByte = function (b, n) {\n  b = String.fromCharCode(b);\n  var d = this.data;\n\n  while (n > 0) {\n    if (n & 1) {\n      d += b;\n    }\n\n    n >>>= 1;\n\n    if (n > 0) {\n      b += b;\n    }\n  }\n\n  this.data = d;\n};\n/**\r\n * Puts bytes in this buffer.\r\n *\r\n * @param bytes the bytes (as a UTF-8 encoded string) to put.\r\n */\n\n\nutil.ByteBuffer.prototype.putBytes = function (bytes) {\n  this.data += bytes;\n};\n/**\r\n * Puts a UTF-16 encoded string into this buffer.\r\n *\r\n * @param str the string to put.\r\n */\n\n\nutil.ByteBuffer.prototype.putString = function (str) {\n  this.data += util.encodeUtf8(str);\n};\n/**\r\n * Puts a 16-bit integer in this buffer in big-endian order.\r\n *\r\n * @param i the 16-bit integer.\r\n */\n\n\nutil.ByteBuffer.prototype.putInt16 = function (i) {\n  this.data += String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF);\n};\n/**\r\n * Puts a 24-bit integer in this buffer in big-endian order.\r\n *\r\n * @param i the 24-bit integer.\r\n */\n\n\nutil.ByteBuffer.prototype.putInt24 = function (i) {\n  this.data += String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF);\n};\n/**\r\n * Puts a 32-bit integer in this buffer in big-endian order.\r\n *\r\n * @param i the 32-bit integer.\r\n */\n\n\nutil.ByteBuffer.prototype.putInt32 = function (i) {\n  this.data += String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF);\n};\n/**\r\n * Puts a 16-bit integer in this buffer in little-endian order.\r\n *\r\n * @param i the 16-bit integer.\r\n */\n\n\nutil.ByteBuffer.prototype.putInt16Le = function (i) {\n  this.data += String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF);\n};\n/**\r\n * Puts a 24-bit integer in this buffer in little-endian order.\r\n *\r\n * @param i the 24-bit integer.\r\n */\n\n\nutil.ByteBuffer.prototype.putInt24Le = function (i) {\n  this.data += String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF);\n};\n/**\r\n * Puts a 32-bit integer in this buffer in little-endian order.\r\n *\r\n * @param i the 32-bit integer.\r\n */\n\n\nutil.ByteBuffer.prototype.putInt32Le = function (i) {\n  this.data += String.fromCharCode(i & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 24 & 0xFF);\n};\n/**\r\n * Puts an n-bit integer in this buffer in big-endian order.\r\n *\r\n * @param i the n-bit integer.\r\n * @param n the number of bits in the integer.\r\n */\n\n\nutil.ByteBuffer.prototype.putInt = function (i, n) {\n  do {\n    n -= 8;\n    this.data += String.fromCharCode(i >> n & 0xFF);\n  } while (n > 0);\n};\n/**\r\n * Puts the given buffer into this buffer.\r\n *\r\n * @param buffer the buffer to put into this one.\r\n */\n\n\nutil.ByteBuffer.prototype.putBuffer = function (buffer) {\n  this.data += buffer.getBytes();\n};\n/**\r\n * Gets a byte from this buffer and advances the read pointer by 1.\r\n *\r\n * @return the byte.\r\n */\n\n\nutil.ByteBuffer.prototype.getByte = function () {\n  return this.data.charCodeAt(this.read++);\n};\n/**\r\n * Gets a uint16 from this buffer in big-endian order and advances the read\r\n * pointer by 2.\r\n *\r\n * @return the uint16.\r\n */\n\n\nutil.ByteBuffer.prototype.getInt16 = function () {\n  var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);\n  this.read += 2;\n  return rval;\n};\n/**\r\n * Gets a uint24 from this buffer in big-endian order and advances the read\r\n * pointer by 3.\r\n *\r\n * @return the uint24.\r\n */\n\n\nutil.ByteBuffer.prototype.getInt24 = function () {\n  var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);\n  this.read += 3;\n  return rval;\n};\n/**\r\n * Gets a uint32 from this buffer in big-endian order and advances the read\r\n * pointer by 4.\r\n *\r\n * @return the word.\r\n */\n\n\nutil.ByteBuffer.prototype.getInt32 = function () {\n  var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);\n  this.read += 4;\n  return rval;\n};\n/**\r\n * Gets a uint16 from this buffer in little-endian order and advances the read\r\n * pointer by 2.\r\n *\r\n * @return the uint16.\r\n */\n\n\nutil.ByteBuffer.prototype.getInt16Le = function () {\n  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;\n  this.read += 2;\n  return rval;\n};\n/**\r\n * Gets a uint24 from this buffer in little-endian order and advances the read\r\n * pointer by 3.\r\n *\r\n * @return the uint24.\r\n */\n\n\nutil.ByteBuffer.prototype.getInt24Le = function () {\n  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;\n  this.read += 3;\n  return rval;\n};\n/**\r\n * Gets a uint32 from this buffer in little-endian order and advances the read\r\n * pointer by 4.\r\n *\r\n * @return the word.\r\n */\n\n\nutil.ByteBuffer.prototype.getInt32Le = function () {\n  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;\n  this.read += 4;\n  return rval;\n};\n/**\r\n * Gets an n-bit integer from this buffer in big-endian order and advances the\r\n * read pointer by n/8.\r\n *\r\n * @param n the number of bits in the integer.\r\n *\r\n * @return the integer.\r\n */\n\n\nutil.ByteBuffer.prototype.getInt = function (n) {\n  var rval = 0;\n\n  do {\n    rval = (rval << n) + this.data.charCodeAt(this.read++);\n    n -= 8;\n  } while (n > 0);\n\n  return rval;\n};\n/**\r\n * Reads bytes out into a UTF-8 string and clears them from the buffer.\r\n *\r\n * @param count the number of bytes to read, undefined, null or 0 for all.\r\n *\r\n * @return a UTF-8 string of bytes.\r\n */\n\n\nutil.ByteBuffer.prototype.getBytes = function (count) {\n  var rval;\n\n  if (count) {\n    // read count bytes\n    count = Math.min(this.length(), count);\n    rval = this.data.slice(this.read, this.read + count);\n    this.read += count;\n  } else if (count === 0) {\n    rval = '';\n  } else {\n    // read all bytes, optimize to only copy when needed\n    rval = this.read === 0 ? this.data : this.data.slice(this.read);\n    this.clear();\n  }\n\n  return rval;\n};\n/**\r\n * Gets a UTF-8 encoded string of the bytes from this buffer without modifying\r\n * the read pointer.\r\n *\r\n * @param count the number of bytes to get, omit to get all.\r\n *\r\n * @return a string full of UTF-8 encoded characters.\r\n */\n\n\nutil.ByteBuffer.prototype.bytes = function (count) {\n  return typeof count === 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);\n};\n/**\r\n * Gets a byte at the given index without modifying the read pointer.\r\n *\r\n * @param i the byte index.\r\n *\r\n * @return the byte.\r\n */\n\n\nutil.ByteBuffer.prototype.at = function (i) {\n  return this.data.charCodeAt(this.read + i);\n};\n/**\r\n * Puts a byte at the given index without modifying the read pointer.\r\n *\r\n * @param i the byte index.\r\n * @param b the byte to put.\r\n */\n\n\nutil.ByteBuffer.prototype.setAt = function (i, b) {\n  this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);\n};\n/**\r\n * Gets the last byte without modifying the read pointer.\r\n *\r\n * @return the last byte.\r\n */\n\n\nutil.ByteBuffer.prototype.last = function () {\n  return this.data.charCodeAt(this.data.length - 1);\n};\n/**\r\n * Creates a copy of this buffer.\r\n *\r\n * @return the copy.\r\n */\n\n\nutil.ByteBuffer.prototype.copy = function () {\n  var c = util.createBuffer(this.data);\n  c.read = this.read;\n  return c;\n};\n/**\r\n * Compacts this buffer.\r\n */\n\n\nutil.ByteBuffer.prototype.compact = function () {\n  if (this.read > 0) {\n    this.data = this.data.slice(this.read);\n    this.read = 0;\n  }\n};\n/**\r\n * Clears this buffer.\r\n */\n\n\nutil.ByteBuffer.prototype.clear = function () {\n  this.data = '';\n  this.read = 0;\n};\n/**\r\n * Shortens this buffer by triming bytes off of the end of this buffer.\r\n *\r\n * @param count the number of bytes to trim off.\r\n */\n\n\nutil.ByteBuffer.prototype.truncate = function (count) {\n  var len = Math.max(0, this.length() - count);\n  this.data = this.data.substr(this.read, len);\n  this.read = 0;\n};\n/**\r\n * Converts this buffer to a hexadecimal string.\r\n *\r\n * @return a hexadecimal string.\r\n */\n\n\nutil.ByteBuffer.prototype.toHex = function () {\n  var rval = '';\n\n  for (var i = this.read; i < this.data.length; ++i) {\n    var b = this.data.charCodeAt(i);\n\n    if (b < 16) {\n      rval += '0';\n    }\n\n    rval += b.toString(16);\n  }\n\n  return rval;\n};\n/**\r\n * Converts this buffer to a UTF-16 string (standard JavaScript string).\r\n *\r\n * @return a UTF-16 string.\r\n */\n\n\nutil.ByteBuffer.prototype.toString = function () {\n  return util.decodeUtf8(this.bytes());\n};\n/**\r\n * Creates a buffer that stores bytes. A value may be given to put into the\r\n * buffer that is either a string of bytes or a UTF-16 string that will\r\n * be encoded using UTF-8 (to do the latter, specify 'utf8' as the encoding).\r\n *\r\n * @param [input] the bytes to wrap (as a string) or a UTF-16 string to encode\r\n *          as UTF-8.\r\n * @param [encoding] (default: 'raw', other: 'utf8').\r\n */\n\n\nutil.createBuffer = function (input, encoding) {\n  encoding = encoding || 'raw';\n\n  if (input !== undefined && encoding === 'utf8') {\n    input = util.encodeUtf8(input);\n  }\n\n  return new util.ByteBuffer(input);\n};\n/**\r\n * Fills a string with a particular value. If you want the string to be a byte\r\n * string, pass in String.fromCharCode(theByte).\r\n *\r\n * @param c the character to fill the string with, use String.fromCharCode\r\n *          to fill the string with a byte value.\r\n * @param n the number of characters of value c to fill with.\r\n *\r\n * @return the filled string.\r\n */\n\n\nutil.fillString = function (c, n) {\n  var s = '';\n\n  while (n > 0) {\n    if (n & 1) {\n      s += c;\n    }\n\n    n >>>= 1;\n\n    if (n > 0) {\n      c += c;\n    }\n  }\n\n  return s;\n};\n/**\r\n * Performs a per byte XOR between two byte strings and returns the result as a\r\n * string of bytes.\r\n *\r\n * @param s1 first string of bytes.\r\n * @param s2 second string of bytes.\r\n * @param n the number of bytes to XOR.\r\n *\r\n * @return the XOR'd result.\r\n */\n\n\nutil.xorBytes = function (s1, s2, n) {\n  var s3 = '';\n  var b = '';\n  var t = '';\n  var i = 0;\n  var c = 0;\n\n  for (; n > 0; --n, ++i) {\n    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);\n\n    if (c >= 10) {\n      s3 += t;\n      t = '';\n      c = 0;\n    }\n\n    t += String.fromCharCode(b);\n    ++c;\n  }\n\n  s3 += t;\n  return s3;\n};\n/**\r\n * Converts a hex string into a UTF-8 string of bytes.\r\n *\r\n * @param hex the hexadecimal string to convert.\r\n *\r\n * @return the string of bytes.\r\n */\n\n\nutil.hexToBytes = function (hex) {\n  var rval = '';\n  var i = 0;\n\n  if (hex.length & 1 === 1) {\n    // odd number of characters, convert first character alone\n    i = 1;\n    rval += String.fromCharCode(parseInt(hex[0], 16));\n  } // convert 2 characters (1 byte) at a time\n\n\n  for (; i < hex.length; i += 2) {\n    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));\n  }\n\n  return rval;\n};\n/**\r\n * Converts a UTF-8 byte string into a string of hexadecimal characters.\r\n *\r\n * @param bytes the byte string to convert.\r\n *\r\n * @return the string of hexadecimal characters.\r\n */\n\n\nutil.bytesToHex = function (bytes) {\n  return util.createBuffer(bytes).toHex();\n};\n/**\r\n * Converts an 32-bit integer to 4-big-endian byte string.\r\n *\r\n * @param i the integer.\r\n *\r\n * @return the byte string.\r\n */\n\n\nutil.int32ToBytes = function (i) {\n  return String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF);\n}; // base64 characters, reverse mapping\n\n\nvar _base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nvar _base64Idx = [\n/* 43 -43 = 0 */\n\n/* '+',  1,  2,  3,'/' */\n62, -1, -1, -1, 63,\n/* '0','1','2','3','4','5','6','7','8','9' */\n52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\n/* 15, 16, 17,'=', 19, 20, 21 */\n-1, -1, -1, 64, -1, -1, -1,\n/* 65 - 43 = 22 */\n\n/* 'A','B','C','D','E','F','G','H','I','J','K','L','M', */\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n/* 'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */\n13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n/* 91 - 43 = 48 */\n\n/* 48, 49, 50, 51, 52, 53 */\n-1, -1, -1, -1, -1, -1,\n/* 97 - 43 = 54 */\n\n/* 'a','b','c','d','e','f','g','h','i','j','k','l','m' */\n26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\n/* 'n','o','p','q','r','s','t','u','v','w','x','y','z' */\n39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];\n/**\r\n * Base64 encodes a UTF-8 string of bytes.\r\n *\r\n * @param input the UTF-8 string of bytes to encode.\r\n * @param maxline the maximum number of encoded bytes per line to use,\r\n *          defaults to none.\r\n *\r\n * @return the base64-encoded output.\r\n */\n\nutil.encode64 = function (input, maxline) {\n  var line = '';\n  var output = '';\n  var chr1;\n  var chr2;\n  var chr3;\n  var i = 0;\n\n  while (i < input.length) {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++); // encode 4 character group\n\n    line += _base64.charAt(chr1 >> 2);\n    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);\n\n    if (isNaN(chr2)) {\n      line += '==';\n    } else {\n      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);\n      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);\n    }\n\n    if (maxline && line.length > maxline) {\n      output += \"\".concat(line.substr(0, maxline), \"\\r\\n\");\n      line = line.substr(maxline);\n    }\n  }\n\n  output += line;\n  return output;\n};\n/**\r\n * Base64 decodes a string into a UTF-8 string of bytes.\r\n *\r\n * @param input the base64-encoded input.\r\n *\r\n * @return the raw bytes.\r\n */\n\n\nutil.decode64 = function (input) {\n  // remove all non-base64 characters\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n  var output = '';\n  var enc1;\n  var enc2;\n  var enc3;\n  var enc4;\n  var i = 0;\n\n  while (i < input.length) {\n    enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n    output += String.fromCharCode(enc1 << 2 | enc2 >> 4);\n\n    if (enc3 !== 64) {\n      // decoded at least 2 bytes\n      output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);\n\n      if (enc4 !== 64) {\n        // decoded 3 bytes\n        output += String.fromCharCode((enc3 & 3) << 6 | enc4);\n      }\n    }\n  }\n\n  return output;\n};\n/**\r\n * UTF-8 encodes the given UTF-16 encoded string (a standard JavaScript\r\n * string). Non-ASCII characters will be encoded as multiple bytes according\r\n * to UTF-8.\r\n *\r\n * @param str the string to encode.\r\n *\r\n * @return the UTF-8 encoded string.\r\n */\n\n\nutil.encodeUtf8 = function (str) {\n  return unescape(encodeURIComponent(str));\n};\n/**\r\n * Decodes a UTF-8 encoded string into a UTF-16 string.\r\n *\r\n * @param str the string to encode.\r\n *\r\n * @return the UTF-16 encoded string (standard JavaScript string).\r\n */\n\n\nutil.decodeUtf8 = function (str) {\n  return decodeURIComponent(escape(str));\n};\n/**\r\n * Deflates the given data using a flash interface.\r\n *\r\n * @param api the flash interface.\r\n * @param bytes the data.\r\n * @param raw true to return only raw deflate data, false to include zlib\r\n *          header and trailer.\r\n *\r\n * @return the deflated data as a string.\r\n */\n\n\nutil.deflate = function (api, bytes, raw) {\n  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval); // strip zlib header and trailer if necessary\n\n  if (raw) {\n    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that\n    // there is a 4-byte DICT (alder-32) block before the data if\n    // its 5th bit is set\n    var start = 2;\n    var flg = bytes.charCodeAt(1);\n\n    if (flg & 0x20) {\n      start = 6;\n    } // zlib trailer is 4 bytes of adler-32\n\n\n    bytes = bytes.substring(start, bytes.length - 4);\n  }\n\n  return bytes;\n};\n/**\r\n * Inflates the given data using a flash interface.\r\n *\r\n * @param api the flash interface.\r\n * @param bytes the data.\r\n * @param raw true if the incoming data has no zlib header or trailer and is\r\n *          raw DEFLATE data.\r\n *\r\n * @return the inflated data as a string, null on error.\r\n */\n\n\nutil.inflate = function (api, bytes, raw) {\n  // TODO: add zlib header and trailer if necessary/possible\n  var rval = api.inflate(util.encode64(bytes)).rval;\n  return rval === null ? null : util.decode64(rval);\n};\n/**\r\n * Sets a storage object.\r\n *\r\n * @param api the storage interface.\r\n * @param id the storage ID to use.\r\n * @param obj the storage object, null to remove.\r\n */\n\n\nvar _setStorageObject = function _setStorageObject(api, id, obj) {\n  if (!api) {\n    throw {\n      message: 'WebStorage not available.'\n    };\n  }\n\n  var rval;\n\n  if (obj === null) {\n    rval = api.removeItem(id);\n  } else {\n    // json-encode and base64-encode object\n    obj = util.encode64(JSON.stringify(obj));\n    rval = api.setItem(id, obj);\n  } // handle potential flash error\n\n\n  if (typeof rval !== 'undefined' && rval.rval !== true) {\n    throw rval.error;\n  }\n};\n/**\r\n * Gets a storage object.\r\n *\r\n * @param api the storage interface.\r\n * @param id the storage ID to use.\r\n *\r\n * @return the storage object entry or null if none exists.\r\n */\n\n\nvar _getStorageObject = function _getStorageObject(api, id) {\n  if (!api) {\n    throw {\n      message: 'WebStorage not available.'\n    };\n  } // get the existing entry\n\n\n  var rval = api.getItem(id);\n  /* Note: We check api.init because we can't do (api == localStorage)\r\n    on IE because of \"Class doesn't support Automation\" exception. Only\r\n    the flash api has an init method so this works too, but we need a\r\n    better solution in the future. */\n  // flash returns item wrapped in an object, handle special case\n\n  if (api.init) {\n    if (rval.rval === null) {\n      if (rval.error) {\n        throw rval.error;\n      } // no error, but also no item\n\n\n      rval = null;\n    } else {\n      rval = rval.rval;\n    }\n  } // handle decoding\n\n\n  if (rval !== null) {\n    // base64-decode and json-decode data\n    rval = JSON.parse(util.decode64(rval));\n  }\n\n  return rval;\n};\n/**\r\n * Stores an item in local storage.\r\n *\r\n * @param api the storage interface.\r\n * @param id the storage ID to use.\r\n * @param key the key for the item.\r\n * @param data the data for the item (any javascript object/primitive).\r\n */\n\n\nvar _setItem = function _setItem(api, id, key, data) {\n  // get storage object\n  var obj = _getStorageObject(api, id);\n\n  if (obj === null) {\n    // create a new storage object\n    obj = {};\n  } // update key\n\n\n  obj[key] = data; // set storage object\n\n  _setStorageObject(api, id, obj);\n};\n/**\r\n * Gets an item from local storage.\r\n *\r\n * @param api the storage interface.\r\n * @param id the storage ID to use.\r\n * @param key the key for the item.\r\n *\r\n * @return the item.\r\n */\n\n\nvar _getItem = function _getItem(api, id, key) {\n  // get storage object\n  var rval = _getStorageObject(api, id);\n\n  if (rval !== null) {\n    // return data at key\n    rval = key in rval ? rval[key] : null;\n  }\n\n  return rval;\n};\n/**\r\n * Removes an item from local storage.\r\n *\r\n * @param api the storage interface.\r\n * @param id the storage ID to use.\r\n * @param key the key for the item.\r\n */\n\n\nvar _removeItem = function _removeItem(api, id, key) {\n  // get storage object\n  var obj = _getStorageObject(api, id);\n\n  if (obj !== null && key in obj) {\n    // remove key\n    delete obj[key]; // see if entry has no keys remaining\n\n    var empty = true;\n\n    for (var prop in tmp) {\n      empty = false;\n      break;\n    }\n\n    if (empty) {\n      // remove entry entirely if no keys are left\n      obj = null;\n    } // set storage object\n\n\n    _setStorageObject(api, id, obj);\n  }\n};\n/**\r\n * Clears the local disk storage identified by the given ID.\r\n *\r\n * @param api the storage interface.\r\n * @param id the storage ID to use.\r\n */\n\n\nvar _clearItems = function _clearItems(api, id) {\n  _setStorageObject(api, id, null);\n};\n/**\r\n * Calls a storage function.\r\n *\r\n * @param func the function to call.\r\n * @param args the arguments for the function.\r\n * @param location the location argument.\r\n *\r\n * @return the return value from the function.\r\n */\n\n\nvar _callStorageFunction = function _callStorageFunction(func, args, location) {\n  var rval = null; // default storage types\n\n  if (typeof location === 'undefined') {\n    location = ['web', 'flash'];\n  } // apply storage types in order of preference\n\n\n  var type;\n  var done = false;\n  var exception = null;\n\n  for (var idx in location) {\n    type = location[idx];\n\n    try {\n      if (type === 'flash' || type === 'both') {\n        if (args[0] === null) {\n          throw {\n            message: 'Flash local storage not available.'\n          };\n        } else {\n          rval = func.apply(this, args);\n          done = type === 'flash';\n        }\n      }\n\n      if (type === 'web' || type === 'both') {\n        args[0] = localStorage;\n        rval = func.apply(this, args);\n        done = true;\n      }\n    } catch (ex) {\n      exception = ex;\n    }\n\n    if (done) {\n      break;\n    }\n  }\n\n  if (!done) {\n    throw exception;\n  }\n\n  return rval;\n};\n/**\r\n * Stores an item on local disk.\r\n *\r\n * The available types of local storage include 'flash', 'web', and 'both'.\r\n *\r\n * The type 'flash' refers to flash local storage (SharedObject). In order\r\n * to use flash local storage, the 'api' parameter must be valid. The type\r\n * 'web' refers to WebStorage, if supported by the browser. The type 'both'\r\n * refers to storing using both 'flash' and 'web', not just one or the\r\n * other.\r\n *\r\n * The location array should list the storage types to use in order of\r\n * preference:\r\n *\r\n * ['flash']: flash only storage\r\n * ['web']: web only storage\r\n * ['both']: try to store in both\r\n * ['flash','web']: store in flash first, but if not available, 'web'\r\n * ['web','flash']: store in web first, but if not available, 'flash'\r\n *\r\n * The location array defaults to: ['web', 'flash']\r\n *\r\n * @param api the flash interface, null to use only WebStorage.\r\n * @param id the storage ID to use.\r\n * @param key the key for the item.\r\n * @param data the data for the item (any javascript object/primitive).\r\n * @param location an array with the preferred types of storage to use.\r\n */\n\n\nutil.setItem = function (api, id, key, data, location) {\n  _callStorageFunction(_setItem, arguments, location);\n};\n/**\r\n * Gets an item on local disk.\r\n *\r\n * Set setItem() for details on storage types.\r\n *\r\n * @param api the flash interface, null to use only WebStorage.\r\n * @param id the storage ID to use.\r\n * @param key the key for the item.\r\n * @param location an array with the preferred types of storage to use.\r\n *\r\n * @return the item.\r\n */\n\n\nutil.getItem = function (api, id, key, location) {\n  return _callStorageFunction(_getItem, arguments, location);\n};\n/**\r\n * Removes an item on local disk.\r\n *\r\n * Set setItem() for details on storage types.\r\n *\r\n * @param api the flash interface.\r\n * @param id the storage ID to use.\r\n * @param key the key for the item.\r\n * @param location an array with the preferred types of storage to use.\r\n */\n\n\nutil.removeItem = function (api, id, key, location) {\n  _callStorageFunction(_removeItem, arguments, location);\n};\n/**\r\n * Clears the local disk storage identified by the given ID.\r\n *\r\n * Set setItem() for details on storage types.\r\n *\r\n * @param api the flash interface if flash is available.\r\n * @param id the storage ID to use.\r\n * @param location an array with the preferred types of storage to use.\r\n */\n\n\nutil.clearItems = function (api, id, location) {\n  _callStorageFunction(_clearItems, arguments, location);\n};\n/**\r\n * Parses the scheme, host, and port from an http(s) url.\r\n *\r\n * @param str the url string.\r\n *\r\n * @return the parsed url object or null if the url is invalid.\r\n */\n\n\nutil.parseUrl = function (str) {\n  // FIXME: this regex looks a bit broken\n  var regex = /^(https?):\\/\\/([^:&^\\/]*):?(\\d*)(.*)$/g;\n  regex.lastIndex = 0;\n  var m = regex.exec(str);\n  var url = m === null ? null : {\n    full: str,\n    scheme: m[1],\n    host: m[2],\n    port: m[3],\n    path: m[4]\n  };\n\n  if (url) {\n    url.fullHost = url.host;\n\n    if (url.port) {\n      if (url.port !== 80 && url.scheme === 'http') {\n        url.fullHost += \":\".concat(url.port);\n      } else if (url.port !== 443 && url.scheme === 'https') {\n        url.fullHost += \":\".concat(url.port);\n      }\n    } else if (url.scheme === 'http') {\n      url.port = 80;\n    } else if (url.scheme === 'https') {\n      url.port = 443;\n    }\n\n    url.full = \"\".concat(url.scheme, \"://\").concat(url.fullHost);\n  }\n\n  return url;\n};\n/* Storage for query variables */\n\n\nvar _queryVariables = null;\n/**\r\n * Returns the window location query variables. Query is parsed on the first\r\n * call and the same object is returned on subsequent calls. The mapping\r\n * is from keys to an array of values. Parameters without values will have\r\n * an object key set but no value added to the value array. Values are\r\n * unescaped.\r\n *\r\n * ...?k1=v1&k2=v2:\r\n * {\r\n *   \"k1\": [\"v1\"],\r\n *   \"k2\": [\"v2\"]\r\n * }\r\n *\r\n * ...?k1=v1&k1=v2:\r\n * {\r\n *   \"k1\": [\"v1\", \"v2\"]\r\n * }\r\n *\r\n * ...?k1=v1&k2:\r\n * {\r\n *   \"k1\": [\"v1\"],\r\n *   \"k2\": []\r\n * }\r\n *\r\n * ...?k1=v1&k1:\r\n * {\r\n *   \"k1\": [\"v1\"]\r\n * }\r\n *\r\n * ...?k1&k1:\r\n * {\r\n *   \"k1\": []\r\n * }\r\n *\r\n * @param query the query string to parse (optional, default to cached\r\n *          results from parsing window location search query).\r\n *\r\n * @return object mapping keys to variables.\r\n */\n\nutil.getQueryVariables = function (query) {\n  var parse = function parse(q) {\n    var rval = {};\n    var kvpairs = q.split('&');\n\n    for (var i = 0; i < kvpairs.length; i++) {\n      var pos = kvpairs[i].indexOf('=');\n      var key;\n      var val;\n\n      if (pos > 0) {\n        key = kvpairs[i].substring(0, pos);\n        val = kvpairs[i].substring(pos + 1);\n      } else {\n        key = kvpairs[i];\n        val = null;\n      }\n\n      if (!(key in rval)) {\n        rval[key] = [];\n      }\n\n      if (val !== null) {\n        rval[key].push(unescape(val));\n      }\n    }\n\n    return rval;\n  };\n\n  var rval;\n\n  if (typeof query === 'undefined') {\n    // set cached variables if needed\n    if (_queryVariables === null) {\n      if (typeof window === 'undefined') {\n        // no query variables available\n        _queryVariables = {};\n      } else {\n        // parse window search query\n        _queryVariables = parse(window.location.search.substring(1));\n      }\n    }\n\n    rval = _queryVariables;\n  } else {\n    // parse given query\n    rval = parse(query);\n  }\n\n  return rval;\n};\n/**\r\n * Parses a fragment into a path and query. This method will take a URI\r\n * fragment and break it up as if it were the main URI. For example:\r\n *    /bar/baz?a=1&b=2\r\n * results in:\r\n *    {\r\n *       path: [\"bar\", \"baz\"],\r\n *       query: {\"k1\": [\"v1\"], \"k2\": [\"v2\"]}\r\n *    }\r\n *\r\n * @return object with a path array and query object.\r\n */\n\n\nutil.parseFragment = function (fragment) {\n  // default to whole fragment\n  var fp = fragment;\n  var fq = ''; // split into path and query if possible at the first '?'\n\n  var pos = fragment.indexOf('?');\n\n  if (pos > 0) {\n    fp = fragment.substring(0, pos);\n    fq = fragment.substring(pos + 1);\n  } // split path based on '/' and ignore first element if empty\n\n\n  var path = fp.split('/');\n\n  if (path.length > 0 && path[0] == '') {\n    path.shift();\n  } // convert query into object\n\n\n  var query = fq == '' ? {} : util.getQueryVariables(fq);\n  return {\n    pathString: fp,\n    queryString: fq,\n    path: path,\n    query: query\n  };\n};\n/**\r\n * Makes a request out of a URI-like request string. This is intended to\r\n * be used where a fragment id (after a URI '#') is parsed as a URI with\r\n * path and query parts. The string should have a path beginning and\r\n * delimited by '/' and optional query parameters following a '?'. The\r\n * query should be a standard URL set of key value pairs delimited by\r\n * '&'. For backwards compatibility the initial '/' on the path is not\r\n * required. The request object has the following API, (fully described\r\n * in the method code):\r\n *    {\r\n *       path: <the path string part>.\r\n *       query: <the query string part>,\r\n *       getPath(i): get part or all of the split path array,\r\n *       getQuery(k, i): get part or all of a query key array,\r\n *       getQueryLast(k, _default): get last element of a query key array.\r\n *    }\r\n *\r\n * @return object with request parameters.\r\n */\n\n\nutil.makeRequest = function (reqString) {\n  var frag = util.parseFragment(reqString);\n  var req = {\n    // full path string\n    path: frag.pathString,\n    // full query string\n    query: frag.queryString,\n\n    /**\r\n     * Get path or element in path.\r\n     *\r\n     * @param i optional path index.\r\n     *\r\n     * @return path or part of path if i provided.\r\n     */\n    getPath: function getPath(i) {\n      return typeof i === 'undefined' ? frag.path : frag.path[i];\n    },\n\n    /**\r\n     * Get query, values for a key, or value for a key index.\r\n     *\r\n     * @param k optional query key.\r\n     * @param i optional query key index.\r\n     *\r\n     * @return query, values for a key, or value for a key index.\r\n     */\n    getQuery: function getQuery(k, i) {\n      var rval;\n\n      if (typeof k === 'undefined') {\n        rval = frag.query;\n      } else {\n        rval = frag.query[k];\n\n        if (rval && typeof i !== 'undefined') {\n          rval = rval[i];\n        }\n      }\n\n      return rval;\n    },\n    getQueryLast: function getQueryLast(k, _default) {\n      var rval;\n      var vals = req.getQuery(k);\n\n      if (vals) {\n        rval = vals[vals.length - 1];\n      } else {\n        rval = _default;\n      }\n\n      return rval;\n    }\n  };\n  return req;\n};\n/**\r\n * Makes a URI out of a path, an object with query parameters, and a\r\n * fragment. Uses jQuery.param() internally for query string creation.\r\n * If the path is an array, it will be joined with '/'.\r\n *\r\n * @param path string path or array of strings.\r\n * @param query object with query parameters. (optional)\r\n * @param fragment fragment string. (optional)\r\n *\r\n * @return string object with request parameters.\r\n */\n\n\nutil.makeLink = function (path, query, fragment) {\n  // join path parts if needed\n  path = jQuery.isArray(path) ? path.join('/') : path;\n  var qstr = jQuery.param(query || {});\n  fragment = fragment || '';\n  return path + (qstr.length > 0 ? \"?\".concat(qstr) : '') + (fragment.length > 0 ? \"#\".concat(fragment) : '');\n};\n/**\r\n * Follows a path of keys deep into an object hierarchy and set a value.\r\n * If a key does not exist or it's value is not an object, create an\r\n * object in it's place. This can be destructive to a object tree if\r\n * leaf nodes are given as non-final path keys.\r\n * Used to avoid exceptions from missing parts of the path.\r\n *\r\n * @param object the starting object.\r\n * @param keys an array of string keys.\r\n * @param value the value to set.\r\n */\n\n\nutil.setPath = function (object, keys, value) {\n  // need to start at an object\n  if (_typeof(object) === 'object' && object !== null) {\n    var i = 0;\n    var len = keys.length;\n\n    while (i < len) {\n      var next = keys[i++];\n\n      if (i == len) {\n        // last\n        object[next] = value;\n      } else {\n        // more\n        var hasNext = next in object;\n\n        if (!hasNext || hasNext && _typeof(object[next]) !== 'object' || hasNext && object[next] === null) {\n          object[next] = {};\n        }\n\n        object = object[next];\n      }\n    }\n  }\n};\n/**\r\n * Follows a path of keys deep into an object hierarchy and return a value.\r\n * If a key does not exist, create an object in it's place.\r\n * Used to avoid exceptions from missing parts of the path.\r\n *\r\n * @param object the starting object.\r\n * @param keys an array of string keys.\r\n * @param _default value to return if path not found.\r\n *\r\n * @return the value at the path if found, else default if given, else\r\n *         undefined.\r\n */\n\n\nutil.getPath = function (object, keys, _default) {\n  var i = 0;\n  var len = keys.length;\n  var hasNext = true;\n\n  while (hasNext && i < len && _typeof(object) === 'object' && object !== null) {\n    var next = keys[i++];\n    hasNext = next in object;\n\n    if (hasNext) {\n      object = object[next];\n    }\n  }\n\n  return hasNext ? object : _default;\n};\n/**\r\n * Follow a path of keys deep into an object hierarchy and delete the\r\n * last one. If a key does not exist, do nothing.\r\n * Used to avoid exceptions from missing parts of the path.\r\n *\r\n * @param object the starting object.\r\n * @param keys an array of string keys.\r\n */\n\n\nutil.deletePath = function (object, keys) {\n  // need to start at an object\n  if (_typeof(object) === 'object' && object !== null) {\n    var i = 0;\n    var len = keys.length;\n\n    while (i < len) {\n      var next = keys[i++];\n\n      if (i == len) {\n        // last\n        delete object[next];\n      } else {\n        // more\n        if (!(next in object) || _typeof(object[next]) !== 'object' || object[next] === null) {\n          break;\n        }\n\n        object = object[next];\n      }\n    }\n  }\n};\n/**\r\n * Check if an object is empty.\r\n *\r\n * Taken from:\r\n * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937\r\n *\r\n * @param object the object to check.\r\n */\n\n\nutil.isEmpty = function (obj) {\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\r\n * Format with simple printf-style interpolation.\r\n *\r\n * %%: literal '%'\r\n * %s,%o: convert next argument into a string.\r\n *\r\n * @param format the string to format.\r\n * @param ... arguments to interpolate into the format string.\r\n */\n\n\nutil.format = function (format) {\n  var re = /%./g; // current match\n\n  var match; // current part\n\n  var part; // current arg index\n\n  var argi = 0; // collected parts to recombine later\n\n  var parts = []; // last index found\n\n  var last = 0; // loop while matches remain\n\n  while (match = re.exec(format)) {\n    part = format.substring(last, re.lastIndex - 2); // don't add empty strings (ie, parts between %s%s)\n\n    if (part.length > 0) {\n      parts.push(part);\n    }\n\n    last = re.lastIndex; // switch on % code\n\n    var code = match[0][1];\n\n    switch (code) {\n      case 's':\n      case 'o':\n        // check if enough arguments were given\n        if (argi < arguments.length) {\n          parts.push(arguments[argi++ + 1]);\n        } else {\n          parts.push('<?>');\n        }\n\n        break;\n      // FIXME: do proper formating for numbers, etc\n      // case 'f':\n      // case 'd':\n\n      case '%':\n        parts.push('%');\n        break;\n\n      default:\n        parts.push(\"<%\".concat(code, \"?>\"));\n    }\n  } // add trailing part of format string\n\n\n  parts.push(format.substring(last));\n  return parts.join('');\n};\n/**\r\n * Formats a number.\r\n *\r\n * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/\r\n */\n\n\nutil.formatNumber = function (number, decimals, dec_point, thousands_sep) {\n  // http://kevin.vanzonneveld.net\n  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // +     bugfix by: Michael White (http://crestidg.com)\n  // +     bugfix by: Benjamin Lupton\n  // +     bugfix by: Allan Jensen (http://www.winternet.no)\n  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n  // *     example 1: number_format(1234.5678, 2, '.', '');\n  // *     returns 1: 1234.57\n  var n = number;\n  var c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;\n  var d = dec_point === undefined ? ',' : dec_point;\n  var t = thousands_sep === undefined ? '.' : thousands_sep;\n  var s = n < 0 ? '-' : '';\n  var i = \"\".concat(parseInt(n = Math.abs(+n || 0).toFixed(c), 10));\n  var j = i.length > 3 ? i.length % 3 : 0;\n  return s + (j ? i.substr(0, j) + t : '') + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\".concat(t)) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');\n};\n/**\r\n * Formats a byte size.\r\n *\r\n * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/\r\n */\n\n\nutil.formatSize = function (size) {\n  if (size >= 1073741824) {\n    size = \"\".concat(util.formatNumber(size / 1073741824, 2, '.', ''), \" GiB\");\n  } else if (size >= 1048576) {\n    size = \"\".concat(util.formatNumber(size / 1048576, 2, '.', ''), \" MiB\");\n  } else if (size >= 1024) {\n    size = \"\".concat(util.formatNumber(size / 1024, 0), \" KiB\");\n  } else {\n    size = \"\".concat(util.formatNumber(size, 0), \" bytes\");\n  }\n\n  return size;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (util);\n\n//# sourceURL=webpack:///./src/core/src/util/forge/forgeutil.js?");

/***/ }),

/***/ "./src/core/src/util/forge/index.js":
/*!******************************************!*\
  !*** ./src/core/src/util/forge/index.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _forgeaes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./forgeaes */ \"./src/core/src/util/forge/forgeaes.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_forgeaes__WEBPACK_IMPORTED_MODULE_0__[\"default\"]); // import './forgeutil';\n\n//# sourceURL=webpack:///./src/core/src/util/forge/index.js?");

/***/ })

});